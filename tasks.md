## 18 - Endpoint для приема входящих сообщений

Цель: Написать Endpoint для приема входящих сообщений Игровым сервером.

Термины:
Игровой сервер - это приложение, на котором вычисляется состояние танковых боев, то есть выполняются все те команды, которые рассматривались на предыдущих занятиях.
Агент - это специальное приложение, на котором игрок запускает свой алгоритм управления своей командой танков.

Для полноценной реализации игры необходимо обеспечить двусторонний обмен данными между Игровым сервером и Агентами. Частью такого обмена будет Endpoint для приема входящих сообщений Игорвым сервером.
В результате выполнения ДЗ будет получен код, основанный на паттернах системы обмена сообщениями для приема входящих сообщений от Агентов.

Цель: применить навыки построения архитектуры, основанной на системе обмена сообщениями.

Описание/Пошаговая инструкция выполнения домашнего задания:
Задача Endpoint принять входящее сообщение от Агента, десериализовать его и передать его на обработку внутрь игрового сервера.
Прием входящих сообщений и их десериализацию скорее всего возьмут на себя те библиотеки, которыми Вы будете пользоваться.
А вот определить какому из танковых боев это сообщение было адресовано (маршрутизация) и его уведомление о входящем сообщении (передача сообщения в обработку) - это то, что придется делать в рамках этого ДЗ.
Организовать Endpoint можно реализовать разными способами. Здесь выбирайте тот, который считаете полезным для своих прикладных задач на работе, а не для данной игры.
Ну или тот, с которым сами бы хотели разобраться.

Ниже приведены разные варианты, что можно было бы сделать:
- Endpoint поверх Tcp/IP или UDP протокола.
- Controller в web-фреймворке.
- Endpoint на основе веб-сокетов.
- Rest
- Подписка на получение сообщений из какого-нибудь Message Broker'а.

Выбор варианта не сильно отразится на остальной архитектуре, то есть концептуально будет одно и тоже, а вот у каждого варианта могут быть свои ньюансы реализации, поэтому степень полезности того или иного способа реализации прямо зависит от того, в какую сторону лично Вы хотите развиваться.

Шаги выполнения ДЗ:

Определить формат сообщений, которые отправляет Агент игровому серверу.

Указание: правила во всех играх могут сильно отличаться друг от друга, поэтому нужно подумать о таком формате, который бы не зависел от текущей реализации конкретных команд, то есть чтобы endpoint не приходилось модифицировать каждый раз, когда мы разработаем новое правило игры.

Как идею для решения поставленной задачи можно рассмотреть следующий набор данных, который стоит передавать в сообщении:
- id игры - для идентификации игры, в рамках которой это сообщение обработано. С помощью этого id можно будет определить получателя сообщения при маршрутизации сообщения внутри игрового сервера.
- id игрового объекта, которому адресовано сообщение. С помощью этого id можно будет определить игровой объект внутри игры, для которого адресовано это сообщение.
- id операции - по этому id в IoC можно будет определить команду, которая будет обрабатывать данное сообщение.
- args - вложенный json объект с параметрами операции. Содержимое этого объекта полностью зависит от команды, которая будет применяться к игровому объекту.

Определить endpoint, который принимает входящее сообщение и конвертирует в команду InterpretCommand.

enpoint должен определить игру, которой адресовано сообщение, создать команду InterpretCommand и поместить эту команду в очередь команд этой игры.

Команда InterpretCommand получает всю информацию об операции, которую необходимо выполнить, параметрах и объекте, над которым эта операция будет выполняться.

Задача команды InetrpretCommand на основе IoC контейнера создать команду для нужного объекта, которая которая соответствует приказу, содержащемуся в сообщении и постановки этой команды в очередь команд игры.

Например, если сообщение указано, что объект с id 548 должен начать двигаться, то результат InterpretCommand заключается можно описать следующим псевдокодом
```csharp
var obj = IoC.Resolve("Игровые объекты", "548"); // "548" получено из входящего сообщения

IoC.Resolve("Установить начальное значение скорости", obj, 2); // значение 2 получено из args переданного в сообщении

var cmd = IoC.Resolve("Движение по прямой", obj); // Решение, что нужно выполнить движение по прямой получено из сообщения
// обратите внимание само значение "Движение по прямой" нельзя читать на прямую из сообщения,
// чтобы избежать инъекции, когда пользователь попытается выполнить действие, которое ему выполнять не позволено

IoC.Resolve("Очередь команд", cmd).Execute(); // Выполняем команду, которая поместит команду cmd в очередь команд игры.
```

Дополнительно:
Можно реализовать двусторонний обмен данными между Игровым сервером и Агентом. Так как для принятия решения о той или иной операции на Агенте необходимо знать текущее состояние танковой битвы. Для этого можно использовать websocket или tcp/ip или любой другой способ. С точки зрения игры это выглядит так - есть команда, при выполнении которой она сериализует состояние игровых объектов и инициирует процесс отправки этих данных на Агент. Далее рассылка сохраненного состояния производится через реализованный двусторонний обмен данными.

Критерии оценки:

- Задача сдана на проверку - 1 балл.
- Код компилируется без ошибок, тесты выполняются успешно. - 1 балл
- Настроен CI, по которому можно определить успешность п. 2 - 2 балла
- Описан формат сообщения 1 балл
    - 2 балла - формат сообщения универсален и удовлетворяет SOLID (принимается, если преподаватель может придумать контрпример, который приводит к изменению формата)
- Реализован endpoint, который вычисляет игру и ставит команду в очередь игры 1 балл
    - 2 балла - если реализация endpoint эффективна, то есть не использует лишние блокировки и примитивы синхронизации, не имеет race conditions.
- Реализована Interpret Command 1 балл
    - 2 балла - если удовлетворяет SOLID (принимается, если преподаватель может придумать контрпример, который приводит к изменению кода команды)

## 16 - Многопоточное выполнение команд

Цель: Разработка многопоточной системы выполнения команд на примере игры "Космический бой".
В результате выполнения ДЗ будет получен код, отвечающий за выполнение множества команд в несколько потоков, устойчивый к появлению новых видов команд и дополнительных ограничений, накладываемых на них.

Описание/Пошаговая инструкция выполнения домашнего задания:

Предположим, что у нас есть набор команд, которые необходимо выполнить. Выполнение команд организуем в несколько потоков.
Для этого будем считать, что у каждого потока есть своя потокобезопасная очередь.
Для того, чтобы выполнить команду, ее необходимо добавить в очередь. Поток читает очередную команду из очереди и выполняет ее.
Если выполнение команды прерывается выброшенным исключением, то поток должен отловить его и продолжить работу.
Если сообщений нет в очереди, то поток засыпает до тех пор, пока очередь пуста.

Последовательность шагов решения:
1. Реализовать код, который запускается в отдельном потоке и делает следующее
    В цикле получает из потокобезопасной очереди команду и запускает ее.
    Выброс исключения из команды не должен прерывать выполнение потока.
2. Написать команду, которая стартует код, написанный в пункте 1 в отдельном потоке.
3. Написать команду, которая останавливает цикл выполнения команд из пункта 1, не дожидаясь их полного завершения (hard stop).
4. Написать команду, которая останавливает цикл выполнения команд из пункта 1, только после того, как все команды завершат свою работу (soft stop).
5. Написать тесты на команду запуска и остановки потока.



Критерии оценки:
1. ДЗ сдано на проверку - 2 балла
2. Код решения опубликован на github/gitlab - 1 балл
3. Настроен CI - 2 балла
4. Код компилируется без ошибок - 1 балл.
5. Написать тест, который проверяет, что после команды старт поток запущен - 1балл и 4 балла - если используются условные события синхронизации.
6. Написать тест, который проверяет, что после команды hard stop, поток завершается - 1 балл
7. Написать тест, который проверяет, что после команды soft stop, поток завершается только после того, как все задачи закончились - 2 балла

## 14 - Генерация адаптеров по интерфейсу

Цель: В рамках данного ДЗ Вы научитесь генерировать адаптеры для интерфейсов, полученных при применении принципа DIP.
ДЗ демонстрирует применение метапрограммирования для решения рутинных задач, а также возможности Reflection и компиляции "на лету" современных языков программирования.

Если задание выполняется на C++, то задание заключается в написании препроцессора, который ищет абстрактные классы и по ним генерирует код адаптера, который включается в состав проекта. Для удобства такой препроцессор стоит запускать на этапе, предшествующем компиляции в процессе сборки, а также стоит подумать об удалении всех
сгенерированных файлов при выполнении команды clear.

Описание/Пошаговая инструкция выполнения домашнего задания:

Предположим, что у нас есть интерфейс
```
interface Spaceship.Operations.IMovable
{
    Vector getPosition();
    void setPosition(Vector newValue);
    Vector getVelocity();
}
```

1. Необходимо по нему сгенерировать следующий класс:
```
class AutoGenerated.MovableAdapter: Spaceship.Operations.IMovable
{
    UObject obj;

    public MovableAdapter(UObject obj) {}

    public Vector getPosition() {
        return IoC.Resolve("Spaceship.Operations.IMovable:position.get", obj);
    }

    public Vector getVelocity() {
        return IoC.Resolve("Spaceship.Operations.IMovable:velocity.get", obj);
    }

    public void setPosition(Vector newValue) {
        IoC.Resolve("Spaceship.Operations.IMovable:position.set", obj, newValue).Execute();
    }
}
```
так, чтобы можно было создавать экземпляры этого класса.

2. Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
`var adapter = IoC.Resolve("Adapter", typeof(IMovable), obj);`

3. Необязательная задача на подумать: если интерфейсе потребуются какие-либо методы, например, как
```
interface Spaceship.Operations.IMovable
{
    Vector getPosition();
    Vector setPosition(Vector newValue);
    Vector getVelocity();
    void finish();
}
```
Придумать реализацию адаптера для подобных методов.

Критерии оценки:

1. Задание сдано на проверку - 1 балл
2. Реализован генератор адаптеров - 3 балла
3. Реализованы тесты на генератор адаптеров - 2 балл
4. Определена стратегия для IoC из п. 2 задания - 2 балла
5. Обработан случай из п. 3 задания - 2 балла

## 12 - IoC Контейнер

https://github.com/zaryanezrya/sturdy/blob/main/sturdy/ioc.py
https://github.com/etyumentcev/appserver/blob/main/appserver/core/Ioc.cs


Цель: Реализовать собственный IoC контейнер, устойчивый к изменению требований.
В результате выполнения домашнего задания Вы получите IoC, который можно будет использовать в качестве фасада в своих проектах.

Описание/Пошаговая инструкция выполнения домашнего задания:

В игре Космичекий бой есть набор операций над игровыми объектами: движение по прямой, поворот, выстрел. При этом содержание этих команд может отличаться для разных игр, в зависимости от того, какие правила игры были выбраны пользователями. Например, пользователи могут ограничить запас ход каждого корабля некоторым количеством топлива, а другой игре запретить поворачиваться кораблям по часовой стрелке и т.д.
IoC может помочь в этом случае, скрыв детали в стратегии разрешения зависимости.
Например,
IoC.Resolve("двигаться прямо", obj);
Возвращает команду, которая чаще всего является макрокомандой и осуществляет один шаг движения по прямой.
Реализовать IoC контейнер, который:

1. Разрешает зависимости с помощью метода, со следующей сигнатурой:
    T IoC.Resolve(string key, params object[] args);

_Указание:_ Если язык программирования не поддерживает Generics, как, например, PHP, то

1. Запись Вам может быть незнакома. Так оеализуется параметрический полиморфизм в таких языках, как C++, C#, Java, Kotlin и др.
2. Тогда просто возвращайте просто ссылку на базовый класс.
3. Регистрация зависимостей также происходит с помощью метода Resolve
    IoC.Resolve("IoC.Register", "aaa", (args) => new A()).Execute();
4. Зависимости можно регистрировать в разных "скоупах"
    IoC.Resolve("Scopes.New", "scopeId").Execute();
    IoC.Resolve("Scopes.Current", "scopeId").Exceute();

_Указание:_ Если Ваш фреймворк допускает работу с многопоточным кодом, то для работы со скоупами используйте ThreadLocal контейнер.

Критерии оценки:

1. Интерфейс IoC устойчив к изменению требований. Оценка: 0 - 3 балла (0 - совсем не устойчив, 3 - преподаватель не смог построить ни одного контрпримера)
2. IoC предоставляет ровно один метод для всех операций. 1 балл
3. IoC предоставляет работу со скоупами для предотвращения сильной связности. 2 балла.
4. Реализованы модульные тесты. 2 балла
5. Реализованы многопоточные тесты. 2 балла

## 10 - Макрокоманды

Научиться обрабатывать ситуации с точки зрения SOLID, когда требуется уточнить существующее поведение без модификации существующего кода.
Предположим, что у нас уже написаны команды MoveCommand и RotateCommand. Теперь возникло новое требование: пользователи в игре могут устанавливать правило - во время движение расходуется топливо, двигаться можно только при наличии топлива.
Реализовать новую возможность можно введя две новые команды.
CheckFuelCommand и BurnFuelCommand.
CheckFuelCommand проверяет, что топлива достаточно, если нет, то выбрасывает исключение CommandException.
BurnFuelCommand уменьшает количество топлива на скорость расхода топлива.
После этого мы можем три команды выстроить в цепочку.
CheckFuelCommand MoveCommand BurnFuelCommand
Чтобы это было прозрачно для пользователя реализуем Макрокоманду - специальную разновидность команды, которая в конструкторе принимает массив команда,
а методе execute их все последовательно выполняет.
При повороте движущегося объекта меняется вектор мгновенной скорости. Напишите команду, которая модифицирует вектор мгновенной скорости, в случае поворота.
Постройте цепочку команд для поворота.

Описание/Пошаговая инструкция выполнения домашнего задания:

1. Реализовать класс CheckFuelComamnd и тесты к нему.
2. Реализовать класс BurnFuelCommand и тесты к нему.
3. Реализовать простейшую макрокоманду и тесты к ней. Здесь простейшая - это значит, что при выбросе исключения вся последовательность команд приостанавливает свое выполнение, а макрокоманда выбрасывает CommandException.
4. Реализовать команду движения по прямой с расходом топлива, используя команды с предыдущих шагов.
5. Реализовать команду для модификации вектора мгновенной скорости при повороте. Необходимо учесть, что не каждый разворачивающийся объект движется.
6. Реализовать команду поворота, которая еще и меняет вектор мгновенной скорости, если есть.

Критерии оценки:

1. Домашнее задание сдано - 1 балл.
2. Реализована команда CheckFuelCommand - 1балл
3. Написаны тесты к CheckFuelComamnd - 1 балл
4. Реализована команда BurnFuelCommand - 1балл
5. Написаны тесты к BurnFuelComamnd - 1 балл
6. Реализована макрокоманда движения по прямой с расходом топлива и тесты к ней - 1 балл
7. Написаны тесты к MacroComamnd - 1 балл
8. Реализована команда ChangeVelocityCommand - 1балл
9. Написаны тесты к ChangeVelocityComamnd - 1 балл
10. Реализована команда поворота, которая еще и меняет вектор мгновенной скорости - 1балл

## 09 - Механизм обработки исключений

https://gist.github.com/zaryanezrya/b51ab8a863e76ac570a3712fb3038474

Научится писать различные стратегии обработки исключений так, чтобы соответствующий блок try-catсh не приходилось модифицировать каждый раз, когда возникает потребность в обработке исключительной ситуации по-новому.

Описание/Пошаговая инструкция выполнения домашнего задания:

Предположим, что все команды находятся в некоторой очереди. Обработка очереди заключается в чтении очередной команды и головы очереди и вызова метода Execute извлеченной команды. Метод Execute() может выбросить любое произвольное исключение.

1. Обернуть вызов Команды в блок try-catch.
2. Обработчик catch должен перехватывать только самое базовое исключение.
3. Есть множество различных обработчиков исключений. Выбор подходящего обработчика исключения делается на основе экземпляра перехваченного исключения и команды, которая выбросила исключение.
4. Реализовать Команду, которая записывает информацию о выброшенном исключении в лог.
5. Реализовать обработчик исключения, который ставит Команду, пишущую в лог в очередь Команд.
6. Реализовать Команду, которая повторяет Команду, выбросившую исключение.
7. Реализовать обработчик исключения, который ставит в очередь Команду - повторитель команды, выбросившей исключение.
8. С помощью Команд из пункта 4 и пункта 6 реализовать следующую обработку исключений:
    при первом выбросе исключения повторить команду, при повторном выбросе исключения записать информацию в лог.
9. Реализовать стратегию обработки исключения - повторить два раза, потом записать в лог. Указание: создать новую команду, точно такую же как в пункте 6. Тип этой команды будет показывать, что Команду не удалось выполнить два раза.

Критерии оценки:

1. ДЗ сдано на оценку - 2 балла
2. Реализованы пункты 4-7. - 2 балла.
3. Написаны тесты к пункту 4-7. - 2 балла
4. Реализован пункт 8. - 1 балл
5. Написаны тесты к пункту 8. - 1 балл
6. Реализован пункт 9. - 1 балл
7. Написаны тесты к пункту 9. - 1 балл


## 08 - Движение игровых объектов по полю

Реализовать движение объектов на игровом поле в рамках подсистемы Игровой сервер.

Критерии оценки:

За выполнение каждого пункта, перечисленного ниже начисляются баллы:

1. ДЗ сдано на проверку - 1 балл
2. Оформлен pull/merge request на github/gitlab - 1 балл
3. Настроен CI - 2 балла
4. Прямолинейное равномерное движение без деформации.
5. 1. Само движение реализовано в виде отдельного класса - 1 балл.
6. 2. Для движущихся объектов определен интерфейс, устойчивый к появлению новых видов движущихся объектов - 1 балл
7. 3. Реализован тесты:

- Для объекта, находящегося в точке (12, 5) и движущегося со скоростью (-7, 3) движение меняет положение объекта на (5, 8)
- Попытка сдвинуть объект, у которого невозможно прочитать положение в пространстве, приводит к ошибке
- Попытка сдвинуть объект, у которого невозможно прочитать значение мгновенной скорости, приводит к ошибке
- Попытка сдвинуть объект, у которого невозможно изменить положение в пространстве, приводит к ошибке
    1 балл

5. Поворот объекта вокруг оси.
6. 1. Сам поворот реализован в виде отдельного класса - 1 балл
7. 2. Для поворачивающегося объекта определен интерфейс, устойчивый к появлению новых видов движущихся объектов - 1 балл
8. 3. Реализован тесты - 1 балл.
